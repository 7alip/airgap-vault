{"version":3,"sources":["./src/app/utils/migration.ts","./src/app/services/migration/migration.service.ts"],"names":[],"mappings":"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","file":"default~pages-account-address-account-address-module~pages-account-share-select-account-share-select~034b9848.js","sourcesContent":["import { AirGapWallet } from '@airgap/coinlib-core'\n\nimport { MnemonicSecret } from '../models/secret'\n\nexport function isSecretMigrated(secret: MnemonicSecret): boolean {\n  return secret.fingerprint && secret.wallets.every(isWalletMigrated)\n}\n\nexport function isWalletMigrated(wallet: AirGapWallet): boolean {\n  return !!wallet.masterFingerprint\n}\n","import { AirGapWallet, AirGapWalletStatus } from '@airgap/coinlib-core'\nimport { Injectable } from '@angular/core'\nimport { BIP32Interface, fromSeed } from 'bip32'\nimport { entropyToMnemonic, mnemonicToSeed } from 'bip39'\n\nimport { MnemonicSecret } from '../../models/secret'\nimport { isSecretMigrated, isWalletMigrated } from '../../utils/migration'\nimport { ErrorCategory, handleErrorLocal } from '../error-handler/error-handler.service'\nimport { NavigationService } from '../navigation/navigation.service'\nimport { SecretsService } from '../secrets/secrets.service'\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MigrationService {\n  constructor(private readonly secretsService: SecretsService, private readonly navigationService: NavigationService) {}\n\n  public async runSecretsMigration(secrets: MnemonicSecret[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (secrets.every(isSecretMigrated)) {\n        resolve()\n      } else {\n        this.navigateToMigrationPage({ secrets }).then(resolve).catch(reject)\n      }\n    })\n  }\n\n  public async runWalletsMigration(wallets: AirGapWallet[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (wallets.every(isWalletMigrated)) {\n        resolve()\n      } else {\n        this.navigateToMigrationPage({ wallets }).then(resolve).catch(reject)\n      }\n    })\n  }\n\n  private async navigateToMigrationPage(navigationData: any): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.navigationService\n        .routeWithState('/migration', {\n          ...navigationData,\n          onSuccess: resolve,\n          onError: reject\n        })\n        .catch((error) => {\n          handleErrorLocal(ErrorCategory.IONIC_NAVIGATION)(error)\n          reject(error)\n        })\n    })\n  }\n\n  public filterMigratedSecrets(secrets: MnemonicSecret[]): [MnemonicSecret[], boolean] {\n    // the migration is a one-time event, after it's run on every secret, they will stabilize on this condition\n    if (secrets.every(isSecretMigrated)) {\n      return [secrets, true]\n    }\n\n    return [secrets.filter(isSecretMigrated), false]\n  }\n\n  public filterMigratedWallets(wallets: AirGapWallet[]): [AirGapWallet[], boolean] {\n    // the migration is a one-time event, after it's run on every wallet, they will stabilize on this condition\n    if (wallets.every(isWalletMigrated)) {\n      return [wallets, true]\n    }\n\n    return [wallets.filter(isWalletMigrated), false]\n  }\n\n  public deepFilterMigratedSecretsAndWallets(secrets: MnemonicSecret[]): [MnemonicSecret[], boolean] {\n    // the migration is a one-time event, after it's run on every secret, they will stabilize on this condition\n    if (secrets.every(isSecretMigrated)) {\n      return [secrets, true]\n    }\n\n    // create a new array of migrated secrets with filtered wallets\n    return [\n      secrets\n        .map((secret: MnemonicSecret) => {\n          if (!secret.fingerprint) {\n            return undefined\n          }\n\n          const [migratedWallets]: [AirGapWallet[], boolean] = this.filterMigratedWallets(secret.wallets)\n          if (migratedWallets.length === 0) {\n            return undefined\n          }\n\n          const newSecret: MnemonicSecret = MnemonicSecret.init(secret)\n          newSecret.wallets = migratedWallets\n\n          return newSecret\n        })\n        .filter((secret: MnemonicSecret | undefined) => secret !== undefined),\n      false\n    ]\n  }\n\n  public async migrateSecret(secret: MnemonicSecret, options: { mnemonic?: string; persist?: boolean } = {}): Promise<void> {\n    const defaultOptions = {\n      persist: false\n    }\n\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    }\n\n    if (secret.fingerprint === undefined) {\n      let mnemonic: string | undefined = resolvedOptions.mnemonic\n      if (mnemonic === undefined) {\n        const entropy: string = await this.secretsService.retrieveEntropyForSecret(secret)\n        mnemonic = entropyToMnemonic(entropy)\n      }\n\n      const seed: Buffer = await mnemonicToSeed(mnemonic)\n      const bip32Node: BIP32Interface = fromSeed(seed)\n      const fingerprint: string = bip32Node.fingerprint.toString('hex')\n\n      secret.fingerprint = fingerprint\n    }\n\n    if (resolvedOptions.persist) {\n      await this.secretsService.addOrUpdateSecret(secret, { setActive: false })\n    }\n  }\n\n  public async migrateWallet(\n    wallet: AirGapWallet,\n    options: { mnemonic?: string; bip39Passphrase?: string; persist?: boolean }\n  ): Promise<void> {\n    const defaultOptions = {\n      bip39Passphrase: '',\n      persist: false\n    }\n\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    }\n\n    if (wallet.masterFingerprint && !resolvedOptions.persist) {\n      return\n    }\n\n    let mnemonic: string | undefined = resolvedOptions.mnemonic\n    let secret: MnemonicSecret | undefined\n    if (mnemonic === undefined || resolvedOptions.persist) {\n      secret = this.secretsService.findByPublicKey(wallet.publicKey)\n    }\n\n    if (mnemonic === undefined && secret !== undefined) {\n      const entropy: string = await this.secretsService.retrieveEntropyForSecret(secret)\n      mnemonic = entropyToMnemonic(entropy)\n    } else if (mnemonic === undefined) {\n      return\n    }\n\n    const publicKey: string = await wallet.protocol.getPublicKeyFromMnemonic(\n      mnemonic,\n      wallet.derivationPath,\n      resolvedOptions.bip39Passphrase\n    )\n\n    if (publicKey !== wallet.publicKey) {\n      throw new Error('Invalid BIP-39 Passphrase')\n    }\n\n    const seed: Buffer = await mnemonicToSeed(mnemonic, resolvedOptions.bip39Passphrase)\n    const bip32Node: BIP32Interface = fromSeed(seed)\n    const fingerprint: string = bip32Node.fingerprint.toString('hex')\n\n    wallet.masterFingerprint = fingerprint\n    wallet.status = AirGapWalletStatus.ACTIVE\n\n    if (resolvedOptions.persist && secret !== undefined) {\n      await this.migrateSecret(secret, { mnemonic: resolvedOptions.mnemonic, persist: resolvedOptions.persist })\n    }\n  }\n}\n"],"sourceRoot":"webpack:///"}